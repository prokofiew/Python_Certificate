 4.1.1 Why do we need functions?

You've come across functions many times so far, but the view on their merits that we have given you has been rather one-sided. 
You've only invoked functions by using them as tools to make life easier, and to simplify time-consuming and tedious tasks.

When you want some data to be printed on the console, you use print(). 
When you want to read the value of a variable, you use input(), coupled with either int() or float().

You've also made use of some methods, which are in fact functions, 
but declared in a very specific way.

Now you'll learn how to write and use your own functions. We'll write several functions together,
from the very simple to the rather complex, which will require your focus and attention.

It often happens that a particular piece of code is repeated many times in your program. 
It's repeated either literally, or with only a few minor modifications, consisting of the use of other variables in the same algorithm. 
It also happens that a programmer cannot resist simplifying their work, and begins to clone such pieces of code using the clipboard and copy-paste operations.

It could end up as greatly frustrating when suddenly it turns out that there was an error in the cloned code. 
The programmer will have a lot of drudgery to find all the places that need corrections. There's also a high risk of the corrections causing errors.

We can now define the first condition which can help you decide when to start writing your own functions: 
if a particular fragment of the code begins to appear in more than one place, 
consider the possibility of isolating it in the form of a function invoked from the points where the original code was placed before.

It may happen that the algorithm you're going to implement is so complex that your code begins to grow in an uncontrolled manner, 
and suddenly you notice that you're not able to navigate through it so easily anymore.

You can try to cope with the issue by commenting the code extensively, 
but soon you find that this dramatically worsens your situation ‒ 
too many comments make the code larger and harder to read. 
Some say that a well-written function should be viewed entirely in one glance.

A good, attentive developer divides the code (or more accurately: the problem) into well-isolated pieces, 
and encodes each of them in the form of a function.

This considerably simplifies the work of the program, 
because each piece of code can be encoded separately, 
and tested separately. The process described here is often called decomposition.

We can now state the second condition: if a piece of code becomes so large that reading and understating it may cause a problem, 
consider dividing it into separate, smaller problems, and implement each of them in the form of a separate function.

This decomposition continues until you get a set of short functions, easy to understand and test.



4.1.2 Decomposition

It often happens that the problem is so large and complex that it cannot be assigned to a single developer, 
and a team of developers have to work on it. 
The problem must be split between several developers in a way that ensures 
their efficient and seamless cooperation.

It seems inconceivable that more than one programmer should write the same piece of code at the same time, 
so the job has to be dispersed among all the team members.

This kind of decomposition has a different purpose to the one described previously ‒ 
it's not only about sharing the work, but also about sharing the responsibility among many developers.

Each of them writes a clearly defined and described set of functions, 
which when combined into the module (we'll tell you about this a bit later) will give the final product.

This leads us directly to the third condition: if you're going to divide the work among multiple programmers,
decompose the problem to allow the product to be implemented as a set of separately written functions packed together in different modules.


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
You mustn't have a function and a variable of the same name.

The following snippet is erroneous:

def message():
    print("Enter a value: ")
 
message = 1

Assigning a value to the name message causes Python to forget its previous role. The function named message becomes unavailable.

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!




==================================
SUMMARY
==================================


1. A function is a block of code that performs a specific task when the function is called (invoked). You can use functions to make your code reusable, better organized, and more readable. Functions can have parameters and return values.

2. There are at least four basic types of functions in Python:

   - built-in functions which are an integral part of Python (such as the print() function). You can see a complete list of built-in Python functions at https://docs.python.org/3/library/functions.html.
   - the ones that come from pre-installed modules (you'll learn about them in the Python Essentials 2 course)
   - user-defined functions which are written by users for users ‒ you can write your own functions and use them freely in your code,
   - the lambda functions (you'll learn about them in the Python Essentials 2 course.)

3. You can define your own function using the def keyword and the following syntax:

def your_function(optional parameters):
    # the body of the function
 

You can define a function which doesn't take any arguments, e.g.:

def message(): # defining a function
    print("Hello") # body of the function
 
message() # calling the function
 

You can define a function which takes arguments, too, just like the one-parameter function below:

def hello(name): # defining a function
    print("Hello,", name) # body of the function
 
 
name = input("Enter your name: ")
 
hello(name) # calling the function
 

We'll tell you more about parametrized functions in the next section. Don't worry.


=================================
4.2.6 SECTION SUMMARY
=================================


1. You can pass information to functions by using parameters. Your functions can have as many parameters as you need.

An example of a one-parameter function:

def hi(name):
    print("Hi,", name)
 
hi("Greg")
 

An example of a two-parameter function:

def hi_all(name_1, name_2):
    print("Hi,", name_2)
    print("Hi,", name_1)
 
hi_all("Sebastian", "Konrad")
 

An example of a three-parameter function:

def address(street, city, postal_code):
    print("Your address is:", street, "St.,", city, postal_code)
 
s = input("Street: ")
p_c = input("Postal Code: ")
c = input("City: ")
address(s, c, p_c)
 

2. You can pass arguments to a function using the following techniques:

    positional argument passing in which the order of arguments passed matters (Ex. 1)
    keyword (named) argument passing in which the order of arguments passed doesn't matter (Ex. 2)
    a mix of positional and keyword argument passing (Ex. 3.)

Ex. 1
def subtra(a, b):
    print(a - b)
 
subtra(5, 2) # outputs: 3
subtra(2, 5) # outputs: -3
 
 
Ex. 2
def subtra(a, b):
    print(a - b)
 
subtra(a=5, b=2) # outputs: 3
subtra(b=2, a=5) # outputs: 3
 
Ex. 3
def subtra(a, b):
    print(a - b)
 
subtra(5, b=2) # outputs: 3
subtra(5, 2) # outputs: 3
 

It's important to remember that positional arguments mustn't follow keyword arguments. That's why if you try to run the following snippet:

def subtra(a, b):
    print(a - b)
 
subtra(5, b=2) # outputs: 3
subtra(a=5, 2) # Syntax Error
 

Python will not let you do it by signalling a SyntaxError.

3. You can use the keyword argument-passing technique to pre-define a value for a given argument:

def name(first_name, last_name="Smith"):
    print(first_name, last_name)
 
name("Andy") # outputs: Andy Smith
name("Betty", "Johnson") # outputs: Betty Johnson (the keyword argument replaced by "Johnson")


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

def add_numbers(a, b=2, c):
    print(a + b + c)
 
add_numbers(a=1, c=3)
 

SyntaxError - a non-default argument (c) follows a default argument (b=2).
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!



===========================================================
4.3.2 A few words about None
===========================================================



Let us introduce you to a very curious value (to be honest, a none value) named None.

Its data doesn't represent any reasonable value ‒ actually, it's not a value at all; hence, it mustn't take part in any expressions.

For example, a snippet like this:

print(None + 2)
 

will cause a runtime error, described by the following diagnostic message:

TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'
Output

Note: None is a keyword.

There are only two kinds of circumstances when None can be safely used:

   - when you assign it to a variable (or return it as a function's result)
   - when you compare it with a variable to diagnose its internal state.


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

def strange_function(n):
    if(n % 2 == 0):
        return True
It's obvious that the strange_function function returns True when its argument is even.

What does it return otherwise?

We can use the following code to check it:

print(strange_function(2))
print(strange_function(1))
 

This is what we see in the console:

True
None

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


============================================
4.3.9 SECTION SUMMARY
============================================

1. You can use the return keyword to tell a function to return some value. The return statement exits the function, e.g.:

def multiply(a, b):
    return a * b
 
print(multiply(3, 4)) # outputs: 12
 
 
def multiply(a, b):
    return
 
print(multiply(3, 4)) # outputs: None
 

2. The result of a function can be easily assigned to a variable, e.g.:

def wishes():
    return "Happy Birthday!"
 
w = wishes()
 
print(w) # outputs: Happy Birthday!
 

Look at the difference in output in the following two examples:

# Example 1
def wishes():
    print("My Wishes")
    return "Happy Birthday"
 
wishes() # outputs: My Wishes
 
 
# Example 2
def wishes():
    print("My Wishes")
    return "Happy Birthday"
 
print(wishes())
 
# outputs: My Wishes
# Happy Birthday
 

3. You can use a list as a function's argument, e.g.:

def hi_everybody(my_list):
    for name in my_list:
        print("Hi,", name)
 
hi_everybody(["Adam", "John", "Lucy"])
 

4. A list can be a function result, too, e.g.:

def create_list(n):
    my_list = []
    for i in range(n):
        my_list.append(i)
    return my_list
 
print(create_list(5))

================================================

def hi():
    return
    print("Hi!")
 
hi()
 

The function will return an implicit None value.

Question 2: What is the output of the following snippet?

def is_int(data):
    if type(data) == int:
        return True
    elif type(data) == float:
        return False
 
print(is_int(5))
print(is_int(5.0))
print(is_int("5"))
 

True
False
None

Question 3: What is the output of the following snippet?

def even_num_lst(ran):
    lst = []
    for num in range(ran):
        if num % 2 == 0:
            lst.append(num)
    return lst
 
print(even_num_lst(11))
 

[0, 2, 4, 6, 8, 10]

Question 4: What is the output of the following snippet?

def list_updater(lst):
    upd_list = []
    for elem in lst:
        elem **= 2
        upd_list.append(elem)
    return upd_list
 
foo = [1, 2, 3, 4, 5]
print(list_updater(foo))
 

[1, 4, 9, 16, 25]



===========================
4.4.4 SECTION SUMMARY
===========================

1. A variable that exists outside a function has scope inside the function body (Example 1) unless the function defines a variable of the same name (Example 2, and Example 3), e.g.:

Example 1:

var = 2
 
 
def mult_by_var(x):
    return x * var
 
 
print(mult_by_var(7)) # outputs: 14
 

Example 2:

def mult(x):
    var = 5
    return x * var
 
 
print(mult(7)) # outputs: 35
 

Example 3:

def mult(x):
    var = 7
    return x * var
 
 
var = 3
print(mult(7)) # outputs: 49
 

2. A variable that exists inside a function has scope inside the function body (Example 4), e.g.:

Example 4:

def adding(x):
    var = 7
    return x + var
 
 
print(adding(4)) # outputs: 11
print(var) # NameError
 

3. You can use the global keyword followed by a variable name to make the variable's scope global, e.g.:

var = 2
print(var) # outputs: 2
 
 
def return_var():
    global var
    var = 5
    return var
 
 
print(return_var()) # outputs: 5
print(var) # outputs: 5
 
