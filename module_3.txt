===========================
MODULE 3 - SECTION 3.1.5
===========================


Priority 	Operator 	
1 				+, - 			unary
2 				** 	
3 				*, /, //, % 	
4 				+, - 			binary
5 				<, <=, >, >= 	
6 				==, != 	



===========================
MODULE 3 - SECTION 3.1.7
===========================
Conditions and conditional execution 


IF
This conditional statement consists of the following, strictly necessary, elements in this and this order only:

   - the if keyword;
   - one or more white spaces;
    an expression (a question or an answer) whose value will be interpreted solely in terms of True (when its value is non-zero) and False (when it is equal to zero);
   - a colon followed by a newline;
   - an indented instruction or set of instructions (at least one instruction is absolutely required); the indentation may be achieved in two ways – by inserting a particular number of spaces (the recommendation is to use four spaces of indentation), or by using the tab character; note: if there is more than one instruction in the indented part, the indentation should be the same in all lines; even though it may look the same if you use tabs mixed with spaces, it's important to make all indentations exactly the same – Python 3 does not allow the mixing of spaces and tabs for indentation.

How does that statement work?

   - If the true_or_not expression represents the truth (i.e., its value is not equal to zero), the indented statement(s) will be executed;
   - if the true_or_not expression does not represent the truth (i.e., its value is equal to zero), the indented statement(s) will be omitted (ignored), and the next executed instruction will be the one after the original indentation level.

ELSE


Thus, there is a new word: else – this is a keyword.

The part of the code which begins with else says what to do if the condition specified for the if is not met (note the colon after the word).

The if-else execution goes as follows:

   - if the condition evaluates to True (its value is not equal to zero), the perform_if_condition_true statement is executed, and the conditional statement comes to an end;
   - if the condition evaluates to False (it is equal to zero), the perform_if_condition_false statement is executed, and the conditional statement comes to an end.


   ===============
   NESTED IF ELSE
   ===============

Nested if-else statements

Now let's discuss two special cases of the conditional statement.

First, consider the case where the instruction placed after the if is another if.

Read what we have planned for this Sunday. If the weather is fine, we'll go for a walk. If we find a nice restaurant, we'll have lunch there. Otherwise, we'll eat a sandwich. If the weather is poor, we'll go to the theater. If there are no tickets, we'll go shopping in the nearest mall.

Let's write the same in Python. Consider carefully the code here:

if the_weather_is_good:
    if nice_restaurant_is_found:
        have_lunch()
    else:
        eat_a_sandwich()
else:
    if tickets_are_available:
        go_to_the_theater()
    else:
        go_shopping()

Here are two important points:

   - this use of the if statement is known as nesting; remember that every else refers to the if which lies at the same indentation level; you need to know this to determine how the ifs and elses pair up;
   - consider how the indentation improves readability, and makes the code easier to understand and trace.

   The way to assemble subsequent if-elif-else statements is sometimes called a cascade.


Some additional attention has to be paid in this case:

   - you mustn't use else without a preceding if;
    else is always the last branch of the cascade, regardless of whether you've used elif or not;
   - else is an optional part of the cascade, and may be omitted;
    if there is an else branch in the cascade, only one of all the branches is executed;
   - if there is no else branch, it's possible that none of the available branches is executed.


===============
FOR LOOP 
===============

There are some new elements. Let us tell you about them:

   - the for keyword opens the for loop; note – there's no condition after it; you don't have to think about conditions, as they're checked internally, without any intervention;
   - any variable after the for keyword is the control variable of the loop; it counts the loop's turns, and does it automatically;
   - the in keyword introduces a syntax element describing the range of possible values being assigned to the control variable;
   - the range() function (this is a very special function) is responsible for generating all the desired values of the control variable; in our example, the function will create (we can even say that it will feed the loop with) subsequent values from the following set: 0, 1, 2 .. 97, 98, 99; note: in this case, the range() function starts its job from 0 and finishes it one step (one integer number) before the value of its argument;
   - note the pass keyword inside the loop body – it does nothing at all; it's an empty instruction – we put it here because the for loop's syntax demands at least one instruction inside the body (by the way – if, elif, else and while express the same thing)


=============================================
THIS WILL HAVE NO OUTPUT - start pętli większy lub równy drugiemu

 for i in range(1, 1):
    print("The value of i is currently", i)

 for i in range(2, 1):
    print("The value of i is currently", i)
============================================


===================
CONTINUE AND BREAK
===================

So far, we've treated the body of the loop as an indivisible and inseparable sequence of instructions that are performed completely at every turn of the loop. However, as a developer, you could be faced with the following choices:

   - it appears that it's unnecessary to continue the loop as a whole; you should refrain from further execution of the loop's body and go further;
   - it appears that you need to start the next turn of the loop without completing the execution of the current turn.

These two instructions are:

   - break – exits the loop immediately, and unconditionally ends the loop's operation; the program begins to execute the nearest instruction after the loop's body;
   - continue – behaves as if the program has suddenly reached the end of the body; the next turn is started and the condition expression is tested immediately.

Both these words are keywords.


===========================
MODULE 3 - SECTION 3.2.12
===========================
The while loop and the else branch 

Both loops, while and for, have one interesting (and rarely used) feature.

We'll show you how it works – try to judge for yourself if it's usable and whether you can live without it or not.

In other words, try to convince yourself if the feature is valuable and useful, or is just syntactic sugar.

Take a look at the snippet in the editor. There's something strange at the end – the else keyword.

As you may have suspected, loops may have the else branch too, like ifs.

The loop's else branch is always executed once, regardless of whether the loop has entered its body or not.


==============================
i = 1
while i < 5:
    print(i)
    i += 1
else:
    print("else:", i)


OUTPUT:
1
2
3
4
else: 5

==============================

i = 5
while i < 5:
    print(i)
    i += 1
else:
    print("else:", i)

OUTPUT:
else: 5

==============================

for i in range(5):
    print(i)
else:
    print("else:", i)

OUTPUT:
0
1
2
3
4
else: 4

==============================

i = 111
for i in range(2, 1):
    print(i)
else:
    print("else:", i)

OUTPUT:
else: 111


IMPORTANT:
The loop's body won't be executed here at all. Note: we've assigned the i variable before the loop.

Run the program and check its output.

When the loop's body isn't executed, the control variable retains the value it had before the loop.

Note: if the control variable doesn't exist before the loop starts, it won't exist when the execution reaches the else branch.


